use std::{cmp, fs};

struct Grid {
    map: Vec<(i128, i128)>,
    target_line: i128,
}

impl Grid {
    fn new(target_line: i128) -> Grid {
        Grid {
            map: vec![],
            target_line,
        }
    }

    fn add_sb_pair(&mut self, sensor: Point, beacon: Point) {
        let distance = (sensor.x - beacon.x).abs() + (sensor.y - beacon.y).abs();
        let dist_to_target = (sensor.y - self.target_line).abs();
        let remaining_distance = distance - dist_to_target;

        if remaining_distance < 0 {
            return;
        }

        let blockout = (sensor.x - remaining_distance, sensor.x + remaining_distance);
        self.add_block(blockout);
    }

    fn add_block(&mut self, new_block: (i128, i128)) {
        self.map.push(new_block);
        self.map.sort_by(|b1, b2| b1.0.cmp(&b2.0));
        self.merge_blocks();
    }

    fn merge_blocks(&mut self) {
        let mut items_to_remove = vec![];

        for i in 0..self.map.len() - 1 {
            if items_to_remove.contains(&i) {
                continue;
            }

            for j in i + 1..self.map.len() {
                if blocks_overlap(self.map[i], self.map[j]) {
                    let min = cmp::min(self.map[i].0, self.map[j].0);
                    let max = cmp::max(self.map[i].1, self.map[j].1);

                    self.map[i] = (min, max);
                    items_to_remove.push(j);
                }
            }
        }

        items_to_remove.sort_by(|a, b| b.cmp(&a));
        items_to_remove.iter().for_each(|index| {
            self.map.remove(*index);
        });
    }

    fn get_blocked_count(&self) -> i128 {
        self.map.iter().map(|block| block.1 - block.0).sum()
    }

    fn print_blocks(&self) {
        println!("{:?}", self.map);
    }
}

fn blocks_overlap(b1: (i128, i128), b2: (i128, i128)) -> bool {
    b1.1 >= b2.0 && b1.1 <= b2.1 || b1.0 >= b2.0 && b1.0 <= b2.1 || b1.0 <= b2.0 && b1.1 >= b2.1
}

#[derive(Debug)]
struct Point {
    x: i128,
    y: i128,
}

impl Point {
    fn new(x: i128, y: i128) -> Point {
        Point { x, y }
    }
}

fn main() {
    let contents = fs::read_to_string("input.txt").expect("Couldn't read file.");
    let grid = fill_grid(&contents, 2_000_000);
    let blocked_count = grid.get_blocked_count();
    grid.print_blocks();
    println!("Answer 1: {blocked_count}");

    (0..=4_000_000).into_iter().for_each(|target| {
        let grid = fill_grid(&contents, target);
    });
}

fn fill_grid(contents: &String, target_line: i128) -> Grid {
    let mut grid = Grid::new(target_line);
    contents
        .lines()
        .map(|line| parse_points(&line))
        .for_each(|(sensor, beacon)| {
            grid.add_sb_pair(sensor, beacon);
        });

    grid
}

fn parse_points(line: &str) -> (Point, Point) {
    let mut split = line.split(['=', ',', ':'].as_ref());

    split.next();
    let sensor_x = split.next().unwrap().parse::<i128>().unwrap();
    split.next();
    let sensor_y = split.next().unwrap().parse::<i128>().unwrap();

    split.next();
    let beacon_x = split.next().unwrap().parse::<i128>().unwrap();
    split.next();
    let beacon_y = split.next().unwrap().parse::<i128>().unwrap();

    let sensor = Point::new(sensor_x, sensor_y);
    let beacon = Point::new(beacon_x, beacon_y);
    (sensor, beacon)
}
